= Chronicle Salt - Java binding to wrap libsodium which implements the NaCl crypto library
Peter Lawrey

This library natively support Chronicle Bytes and can sign and verify data entirely off heap. This saves copying data to/from byte[] (not creating them)

=== Based on
This library is a port of the https://github.com/abstractj/kalium[Abstractj Kalium] library to use Chronicle Bytes off heap instead of byte[] on heap.

Using off heap data directly improves performance and scalability.

=== Requirements

* JDK 8 or http://www.oracle.com/technetwork/java/javase/downloads/index.html[higher]
* http://maven.apache.org/guides/getting-started/[Apache Maven]

=== Installation

==== libsodium

Chronicle Salt uses https://www.gitbook.com/book/jedisct1/libsodium/details[libsodium] wrapped via https://github.com/jnr/jnr-ffi[jnr-ffi]

For a more detailed explanation, please refer to
https://github.com/cryptosphere/rbnacl/blob/master/README.md[RbNaCl's documentation]

==== Linux

Linux users can download the source tar for Linux

- Download `libsodium` from https://download.libsodium.org/libsodium/releases/
- Choose the version of `libsodium` you wish to use
    - The archives follow the following pattern: libsodium-{version}.tar.gz
- `tar xzvf libsodium-{version}.tar.gz`
- `cd libsodium-{version}`
- `./configure`
- `make`
- `sudo make install`

==== OSX

OS X users can get libsodium via http://mxcl.github.com/homebrew/[homebrew] with:

    brew install libsodium

==== Windows

Windows users will need to provide the pre-build binaries from `libsodium`.

- Download `libsodium` from https://download.libsodium.org/libsodium/releases/
- Choose the version of `libsodium` you wish to use
    - The archives follow the following pattern: libsodium-{version}-msvc.zip
- From the archive find the artifacts compiled for your architecture and then the MSVC tool set of your choice
    - For example: `v141 // these were compiled against the MSVC v141 (i.e. Visual Studio 2017)`
- Extract from the archive the `dll` library files into **one** of the following locations:
    - into the `lib` at the root of the working directory directory of your project.
    - into a location that is included in your `PATH` environment variable.

For example, on my Windows 10 machine with a x64 architecture:
```
{archive root}
└───x64
    ...
    └───Release
        ...
        └───v141
            ...
            └───dynamic <- copy the library files from this locaiton.
```

== Using Chronicle Salt

=== Generating Random Bytes

.Generating random bytes which could be used for a private key
[source, Java]
----
    Bytes rand = Ed25519.generateRandomBytes(32);
----

=== Generating a public and secret key from a seed

.Generating private first and then a public and secret key
[source, Java]
----
    Bytes privateKey = Ed25519.generatePrivateKey();

    Bytes publicKey = Bytes.allocateElasticDirect();
    Bytes secretKey = Bytes.allocateElasticDirect();

    Ed25519.privateToPublicAndSecret(publicKey, secretKey, privateKey);
----

NOTE: The secret key holds the private AND public key and is needed for some operations.

=== Viewing keys as a hexadecimal dump

.Viewing a three keys
[source, Java]
----
    System.out.println(privateKey.toHexString());
    System.out.println(publicKey.toHexString());
    System.out.println(secretKey.toHexString());
----

Prints something like

.private, public and secret keys
----
00000000 54 c8 b8 05 5a df 56 9f  8a ae b4 72 2c 69 26 42 T···Z·V· ···r,i&B
00000010 99 c6 d4 36 13 4c cc 2b  83 04 da c5 71 75 b0 1a ···6·L·+ ····qu··

00000000 95 65 db 8d 48 06 12 ae  c4 fe 44 c1 d9 07 5f 19 ·e··H··· ··D···_·
00000010 19 de 6b 13 cc 24 67 27  3a bf 9b ce 25 c8 a1 33 ··k··$g' :···%··3

00000000 54 c8 b8 05 5a df 56 9f  8a ae b4 72 2c 69 26 42 T···Z·V· ···r,i&B
00000010 99 c6 d4 36 13 4c cc 2b  83 04 da c5 71 75 b0 1a ···6·L·+ ····qu··
00000020 95 65 db 8d 48 06 12 ae  c4 fe 44 c1 d9 07 5f 19 ·e··H··· ··D···_·
00000030 19 de 6b 13 cc 24 67 27  3a bf 9b ce 25 c8 a1 33 ··k··$g' :···%··3
----


=== Signing a message

After creating a message, it can be signed.

NOTE: The `sigAndMsg` includes the signature and the messages as this is the way the underlying library is written.

.Signing a message
[source, Java]
----
    Bytes signAndMsg = Bytes.allocateDirect(Ed25519.SIGANTURE_LENGTH + message.readRemaining());
    Ed25519.sign(signAndMsg, message, secretKey);
----

=== Verifying a message

Once a message has been signed, you can verify it using the public key alone.

.Verifying a message
[source, Java]
----
    boolean verified = Ed25519.verify(sigAndMsg, publicKey);
----

== Benchmark

The library can be run in parallel to improve throughput

|===
| system | sign | verify 
| i7-7700HQ 4 core |  64K/s | 26K/s 
| i7-7820X 8 core | 206K/s | 87K/s
| E5-2650 v4 24 core | 306K/s | 154K/s
| E5-2650 v4 24 core, batch | 506K/s | 202K/s
|===
